<?php
/**
 * CallroutingcontractsApi
 * PHP version 5
 *
 * @category Class
 * @package  LeadspediaApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * LeadsPedia API Reference
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.10
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace LeadspediaApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use LeadspediaApi\ApiException;
use LeadspediaApi\Configuration;
use LeadspediaApi\HeaderSelector;
use LeadspediaApi\ObjectSerializer;

/**
 * CallroutingcontractsApi Class Doc Comment
 *
 * @category Class
 * @package  LeadspediaApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CallroutingcontractsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation callRoutingContractschangeModedo
     *
     * Change Mode
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $mode mode (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractschangeModedo($contract_id, $mode)
    {
        $this->callRoutingContractschangeModedoWithHttpInfo($contract_id, $mode);
    }

    /**
     * Operation callRoutingContractschangeModedoWithHttpInfo
     *
     * Change Mode
     *
     * @param  int $contract_id (required)
     * @param  string $mode (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractschangeModedoWithHttpInfo($contract_id, $mode)
    {
        $returnType = '';
        $request = $this->callRoutingContractschangeModedoRequest($contract_id, $mode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractschangeModedoAsync
     *
     * Change Mode
     *
     * @param  int $contract_id (required)
     * @param  string $mode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractschangeModedoAsync($contract_id, $mode)
    {
        return $this->callRoutingContractschangeModedoAsyncWithHttpInfo($contract_id, $mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractschangeModedoAsyncWithHttpInfo
     *
     * Change Mode
     *
     * @param  int $contract_id (required)
     * @param  string $mode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractschangeModedoAsyncWithHttpInfo($contract_id, $mode)
    {
        $returnType = '';
        $request = $this->callRoutingContractschangeModedoRequest($contract_id, $mode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractschangeModedo'
     *
     * @param  int $contract_id (required)
     * @param  string $mode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractschangeModedoRequest($contract_id, $mode)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractschangeModedo'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling callRoutingContractschangeModedo'
            );
        }

        $resourcePath = '/callRoutingContracts/changeMode.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractschangeStatusdo
     *
     * Change Status
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $status status (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractschangeStatusdo($contract_id, $status)
    {
        $this->callRoutingContractschangeStatusdoWithHttpInfo($contract_id, $status);
    }

    /**
     * Operation callRoutingContractschangeStatusdoWithHttpInfo
     *
     * Change Status
     *
     * @param  int $contract_id (required)
     * @param  string $status (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractschangeStatusdoWithHttpInfo($contract_id, $status)
    {
        $returnType = '';
        $request = $this->callRoutingContractschangeStatusdoRequest($contract_id, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractschangeStatusdoAsync
     *
     * Change Status
     *
     * @param  int $contract_id (required)
     * @param  string $status (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractschangeStatusdoAsync($contract_id, $status)
    {
        return $this->callRoutingContractschangeStatusdoAsyncWithHttpInfo($contract_id, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractschangeStatusdoAsyncWithHttpInfo
     *
     * Change Status
     *
     * @param  int $contract_id (required)
     * @param  string $status (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractschangeStatusdoAsyncWithHttpInfo($contract_id, $status)
    {
        $returnType = '';
        $request = $this->callRoutingContractschangeStatusdoRequest($contract_id, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractschangeStatusdo'
     *
     * @param  int $contract_id (required)
     * @param  string $status (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractschangeStatusdoRequest($contract_id, $status)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractschangeStatusdo'
            );
        }
        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling callRoutingContractschangeStatusdo'
            );
        }

        $resourcePath = '/callRoutingContracts/changeStatus.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractscreatedo
     *
     * Create
     *
     * @param  int $vertical_id vertical_id (required)
     * @param  int $advertiser_id advertiser_id (required)
     * @param  string $contract_name contract_name (required)
     * @param  BigDecimal $default_price default_price (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractscreatedo($vertical_id, $advertiser_id, $contract_name, $default_price)
    {
        $this->callRoutingContractscreatedoWithHttpInfo($vertical_id, $advertiser_id, $contract_name, $default_price);
    }

    /**
     * Operation callRoutingContractscreatedoWithHttpInfo
     *
     * Create
     *
     * @param  int $vertical_id (required)
     * @param  int $advertiser_id (required)
     * @param  string $contract_name (required)
     * @param  BigDecimal $default_price (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractscreatedoWithHttpInfo($vertical_id, $advertiser_id, $contract_name, $default_price)
    {
        $returnType = '';
        $request = $this->callRoutingContractscreatedoRequest($vertical_id, $advertiser_id, $contract_name, $default_price);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractscreatedoAsync
     *
     * Create
     *
     * @param  int $vertical_id (required)
     * @param  int $advertiser_id (required)
     * @param  string $contract_name (required)
     * @param  BigDecimal $default_price (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractscreatedoAsync($vertical_id, $advertiser_id, $contract_name, $default_price)
    {
        return $this->callRoutingContractscreatedoAsyncWithHttpInfo($vertical_id, $advertiser_id, $contract_name, $default_price)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractscreatedoAsyncWithHttpInfo
     *
     * Create
     *
     * @param  int $vertical_id (required)
     * @param  int $advertiser_id (required)
     * @param  string $contract_name (required)
     * @param  BigDecimal $default_price (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractscreatedoAsyncWithHttpInfo($vertical_id, $advertiser_id, $contract_name, $default_price)
    {
        $returnType = '';
        $request = $this->callRoutingContractscreatedoRequest($vertical_id, $advertiser_id, $contract_name, $default_price);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractscreatedo'
     *
     * @param  int $vertical_id (required)
     * @param  int $advertiser_id (required)
     * @param  string $contract_name (required)
     * @param  BigDecimal $default_price (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractscreatedoRequest($vertical_id, $advertiser_id, $contract_name, $default_price)
    {
        // verify the required parameter 'vertical_id' is set
        if ($vertical_id === null || (is_array($vertical_id) && count($vertical_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vertical_id when calling callRoutingContractscreatedo'
            );
        }
        // verify the required parameter 'advertiser_id' is set
        if ($advertiser_id === null || (is_array($advertiser_id) && count($advertiser_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $advertiser_id when calling callRoutingContractscreatedo'
            );
        }
        // verify the required parameter 'contract_name' is set
        if ($contract_name === null || (is_array($contract_name) && count($contract_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_name when calling callRoutingContractscreatedo'
            );
        }
        // verify the required parameter 'default_price' is set
        if ($default_price === null || (is_array($default_price) && count($default_price) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $default_price when calling callRoutingContractscreatedo'
            );
        }

        $resourcePath = '/callRoutingContracts/create.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($vertical_id !== null) {
            $queryParams['verticalID'] = ObjectSerializer::toQueryValue($vertical_id);
        }
        // query params
        if ($advertiser_id !== null) {
            $queryParams['advertiserID'] = ObjectSerializer::toQueryValue($advertiser_id);
        }
        // query params
        if ($contract_name !== null) {
            $queryParams['contractName'] = ObjectSerializer::toQueryValue($contract_name);
        }
        // query params
        if ($default_price !== null) {
            $queryParams['defaultPrice'] = ObjectSerializer::toQueryValue($default_price);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsdeleteScheduledPausedo
     *
     * Delete Scheduled Pause
     *
     * @param  int $scheduled_pause_id scheduled_pause_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsdeleteScheduledPausedo($scheduled_pause_id)
    {
        $this->callRoutingContractsdeleteScheduledPausedoWithHttpInfo($scheduled_pause_id);
    }

    /**
     * Operation callRoutingContractsdeleteScheduledPausedoWithHttpInfo
     *
     * Delete Scheduled Pause
     *
     * @param  int $scheduled_pause_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsdeleteScheduledPausedoWithHttpInfo($scheduled_pause_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsdeleteScheduledPausedoRequest($scheduled_pause_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsdeleteScheduledPausedoAsync
     *
     * Delete Scheduled Pause
     *
     * @param  int $scheduled_pause_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsdeleteScheduledPausedoAsync($scheduled_pause_id)
    {
        return $this->callRoutingContractsdeleteScheduledPausedoAsyncWithHttpInfo($scheduled_pause_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsdeleteScheduledPausedoAsyncWithHttpInfo
     *
     * Delete Scheduled Pause
     *
     * @param  int $scheduled_pause_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsdeleteScheduledPausedoAsyncWithHttpInfo($scheduled_pause_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsdeleteScheduledPausedoRequest($scheduled_pause_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsdeleteScheduledPausedo'
     *
     * @param  int $scheduled_pause_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsdeleteScheduledPausedoRequest($scheduled_pause_id)
    {
        // verify the required parameter 'scheduled_pause_id' is set
        if ($scheduled_pause_id === null || (is_array($scheduled_pause_id) && count($scheduled_pause_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_pause_id when calling callRoutingContractsdeleteScheduledPausedo'
            );
        }

        $resourcePath = '/callRoutingContracts/deleteScheduledPause.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($scheduled_pause_id !== null) {
            $queryParams['scheduledPauseID'] = ObjectSerializer::toQueryValue($scheduled_pause_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsdeletedo
     *
     * Delete
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsdeletedo($contract_id)
    {
        $this->callRoutingContractsdeletedoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsdeletedoWithHttpInfo
     *
     * Delete
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsdeletedoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsdeletedoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsdeletedoAsync
     *
     * Delete
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsdeletedoAsync($contract_id)
    {
        return $this->callRoutingContractsdeletedoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsdeletedoAsyncWithHttpInfo
     *
     * Delete
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsdeletedoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsdeletedoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsdeletedo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsdeletedoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsdeletedo'
            );
        }

        $resourcePath = '/callRoutingContracts/delete.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetAlldo
     *
     * Get All
     *
     * @param  int $advertiser_id advertiser_id (optional)
     * @param  int $contract_id contract_id (optional)
     * @param  int $vertical_id vertical_id (optional)
     * @param  string $status status (optional)
     * @param  int $start start (optional)
     * @param  int $limit limit (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetAlldo($advertiser_id = null, $contract_id = null, $vertical_id = null, $status = null, $start = null, $limit = null)
    {
        $this->callRoutingContractsgetAlldoWithHttpInfo($advertiser_id, $contract_id, $vertical_id, $status, $start, $limit);
    }

    /**
     * Operation callRoutingContractsgetAlldoWithHttpInfo
     *
     * Get All
     *
     * @param  int $advertiser_id (optional)
     * @param  int $contract_id (optional)
     * @param  int $vertical_id (optional)
     * @param  string $status (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetAlldoWithHttpInfo($advertiser_id = null, $contract_id = null, $vertical_id = null, $status = null, $start = null, $limit = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetAlldoRequest($advertiser_id, $contract_id, $vertical_id, $status, $start, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetAlldoAsync
     *
     * Get All
     *
     * @param  int $advertiser_id (optional)
     * @param  int $contract_id (optional)
     * @param  int $vertical_id (optional)
     * @param  string $status (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetAlldoAsync($advertiser_id = null, $contract_id = null, $vertical_id = null, $status = null, $start = null, $limit = null)
    {
        return $this->callRoutingContractsgetAlldoAsyncWithHttpInfo($advertiser_id, $contract_id, $vertical_id, $status, $start, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetAlldoAsyncWithHttpInfo
     *
     * Get All
     *
     * @param  int $advertiser_id (optional)
     * @param  int $contract_id (optional)
     * @param  int $vertical_id (optional)
     * @param  string $status (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetAlldoAsyncWithHttpInfo($advertiser_id = null, $contract_id = null, $vertical_id = null, $status = null, $start = null, $limit = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetAlldoRequest($advertiser_id, $contract_id, $vertical_id, $status, $start, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetAlldo'
     *
     * @param  int $advertiser_id (optional)
     * @param  int $contract_id (optional)
     * @param  int $vertical_id (optional)
     * @param  string $status (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetAlldoRequest($advertiser_id = null, $contract_id = null, $vertical_id = null, $status = null, $start = null, $limit = null)
    {

        $resourcePath = '/callRoutingContracts/getAll.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($advertiser_id !== null) {
            $queryParams['advertiserID'] = ObjectSerializer::toQueryValue($advertiser_id);
        }
        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($vertical_id !== null) {
            $queryParams['verticalID'] = ObjectSerializer::toQueryValue($vertical_id);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetBasicInfodo
     *
     * Get Basic Info
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetBasicInfodo($contract_id)
    {
        $this->callRoutingContractsgetBasicInfodoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetBasicInfodoWithHttpInfo
     *
     * Get Basic Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetBasicInfodoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetBasicInfodoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetBasicInfodoAsync
     *
     * Get Basic Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetBasicInfodoAsync($contract_id)
    {
        return $this->callRoutingContractsgetBasicInfodoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetBasicInfodoAsyncWithHttpInfo
     *
     * Get Basic Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetBasicInfodoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetBasicInfodoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetBasicInfodo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetBasicInfodoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetBasicInfodo'
            );
        }

        $resourcePath = '/callRoutingContracts/getBasicInfo.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetBillableTransfersCapInfodo
     *
     * Get Billable Transfers Cap Info
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetBillableTransfersCapInfodo($contract_id)
    {
        $this->callRoutingContractsgetBillableTransfersCapInfodoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetBillableTransfersCapInfodoWithHttpInfo
     *
     * Get Billable Transfers Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetBillableTransfersCapInfodoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetBillableTransfersCapInfodoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetBillableTransfersCapInfodoAsync
     *
     * Get Billable Transfers Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetBillableTransfersCapInfodoAsync($contract_id)
    {
        return $this->callRoutingContractsgetBillableTransfersCapInfodoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetBillableTransfersCapInfodoAsyncWithHttpInfo
     *
     * Get Billable Transfers Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetBillableTransfersCapInfodoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetBillableTransfersCapInfodoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetBillableTransfersCapInfodo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetBillableTransfersCapInfodoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetBillableTransfersCapInfodo'
            );
        }

        $resourcePath = '/callRoutingContracts/getBillableTransfersCapInfo.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetPortalSettingsdo
     *
     * Get Portal Settings
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetPortalSettingsdo($contract_id)
    {
        $this->callRoutingContractsgetPortalSettingsdoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetPortalSettingsdoWithHttpInfo
     *
     * Get Portal Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetPortalSettingsdoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetPortalSettingsdoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetPortalSettingsdoAsync
     *
     * Get Portal Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetPortalSettingsdoAsync($contract_id)
    {
        return $this->callRoutingContractsgetPortalSettingsdoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetPortalSettingsdoAsyncWithHttpInfo
     *
     * Get Portal Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetPortalSettingsdoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetPortalSettingsdoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetPortalSettingsdo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetPortalSettingsdoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetPortalSettingsdo'
            );
        }

        $resourcePath = '/callRoutingContracts/getPortalSettings.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetRepeatCallsSettingsdo
     *
     * Get Repeat Calls Settings
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetRepeatCallsSettingsdo($contract_id)
    {
        $this->callRoutingContractsgetRepeatCallsSettingsdoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetRepeatCallsSettingsdoWithHttpInfo
     *
     * Get Repeat Calls Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetRepeatCallsSettingsdoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetRepeatCallsSettingsdoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetRepeatCallsSettingsdoAsync
     *
     * Get Repeat Calls Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetRepeatCallsSettingsdoAsync($contract_id)
    {
        return $this->callRoutingContractsgetRepeatCallsSettingsdoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetRepeatCallsSettingsdoAsyncWithHttpInfo
     *
     * Get Repeat Calls Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetRepeatCallsSettingsdoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetRepeatCallsSettingsdoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetRepeatCallsSettingsdo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetRepeatCallsSettingsdoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetRepeatCallsSettingsdo'
            );
        }

        $resourcePath = '/callRoutingContracts/getRepeatCallsSettings.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetReturnsSettingsdo
     *
     * Get Returns Settings
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetReturnsSettingsdo($contract_id)
    {
        $this->callRoutingContractsgetReturnsSettingsdoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetReturnsSettingsdoWithHttpInfo
     *
     * Get Returns Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetReturnsSettingsdoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetReturnsSettingsdoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetReturnsSettingsdoAsync
     *
     * Get Returns Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetReturnsSettingsdoAsync($contract_id)
    {
        return $this->callRoutingContractsgetReturnsSettingsdoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetReturnsSettingsdoAsyncWithHttpInfo
     *
     * Get Returns Settings
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetReturnsSettingsdoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetReturnsSettingsdoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetReturnsSettingsdo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetReturnsSettingsdoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetReturnsSettingsdo'
            );
        }

        $resourcePath = '/callRoutingContracts/getReturnsSettings.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetRevenueCapInfodo
     *
     * Get Revenue Cap Info
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetRevenueCapInfodo($contract_id)
    {
        $this->callRoutingContractsgetRevenueCapInfodoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetRevenueCapInfodoWithHttpInfo
     *
     * Get Revenue Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetRevenueCapInfodoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetRevenueCapInfodoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetRevenueCapInfodoAsync
     *
     * Get Revenue Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetRevenueCapInfodoAsync($contract_id)
    {
        return $this->callRoutingContractsgetRevenueCapInfodoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetRevenueCapInfodoAsyncWithHttpInfo
     *
     * Get Revenue Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetRevenueCapInfodoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetRevenueCapInfodoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetRevenueCapInfodo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetRevenueCapInfodoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetRevenueCapInfodo'
            );
        }

        $resourcePath = '/callRoutingContracts/getRevenueCapInfo.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetScheduledPausedo
     *
     * Get Scheduled Pause
     *
     * @param  int $contract_id contract_id (optional)
     * @param  int $start start (optional)
     * @param  int $limit limit (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetScheduledPausedo($contract_id = null, $start = null, $limit = null)
    {
        $this->callRoutingContractsgetScheduledPausedoWithHttpInfo($contract_id, $start, $limit);
    }

    /**
     * Operation callRoutingContractsgetScheduledPausedoWithHttpInfo
     *
     * Get Scheduled Pause
     *
     * @param  int $contract_id (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetScheduledPausedoWithHttpInfo($contract_id = null, $start = null, $limit = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetScheduledPausedoRequest($contract_id, $start, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetScheduledPausedoAsync
     *
     * Get Scheduled Pause
     *
     * @param  int $contract_id (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetScheduledPausedoAsync($contract_id = null, $start = null, $limit = null)
    {
        return $this->callRoutingContractsgetScheduledPausedoAsyncWithHttpInfo($contract_id, $start, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetScheduledPausedoAsyncWithHttpInfo
     *
     * Get Scheduled Pause
     *
     * @param  int $contract_id (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetScheduledPausedoAsyncWithHttpInfo($contract_id = null, $start = null, $limit = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetScheduledPausedoRequest($contract_id, $start, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetScheduledPausedo'
     *
     * @param  int $contract_id (optional)
     * @param  int $start (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetScheduledPausedoRequest($contract_id = null, $start = null, $limit = null)
    {

        $resourcePath = '/callRoutingContracts/getScheduledPause.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsgetTransfersCapInfodo
     *
     * Get Transfers Cap Info
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsgetTransfersCapInfodo($contract_id)
    {
        $this->callRoutingContractsgetTransfersCapInfodoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsgetTransfersCapInfodoWithHttpInfo
     *
     * Get Transfers Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsgetTransfersCapInfodoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetTransfersCapInfodoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsgetTransfersCapInfodoAsync
     *
     * Get Transfers Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetTransfersCapInfodoAsync($contract_id)
    {
        return $this->callRoutingContractsgetTransfersCapInfodoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsgetTransfersCapInfodoAsyncWithHttpInfo
     *
     * Get Transfers Cap Info
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsgetTransfersCapInfodoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsgetTransfersCapInfodoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsgetTransfersCapInfodo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsgetTransfersCapInfodoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsgetTransfersCapInfodo'
            );
        }

        $resourcePath = '/callRoutingContracts/getTransfersCapInfo.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsremoveExpirationDatedo
     *
     * Remove Expiration Date
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsremoveExpirationDatedo($contract_id)
    {
        $this->callRoutingContractsremoveExpirationDatedoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsremoveExpirationDatedoWithHttpInfo
     *
     * Remove Expiration Date
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsremoveExpirationDatedoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsremoveExpirationDatedoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsremoveExpirationDatedoAsync
     *
     * Remove Expiration Date
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsremoveExpirationDatedoAsync($contract_id)
    {
        return $this->callRoutingContractsremoveExpirationDatedoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsremoveExpirationDatedoAsyncWithHttpInfo
     *
     * Remove Expiration Date
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsremoveExpirationDatedoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsremoveExpirationDatedoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsremoveExpirationDatedo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsremoveExpirationDatedoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsremoveExpirationDatedo'
            );
        }

        $resourcePath = '/callRoutingContracts/removeExpirationDate.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsremoveWhisperMessagedo
     *
     * Remove Whisper Message
     *
     * @param  int $contract_id contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsremoveWhisperMessagedo($contract_id)
    {
        $this->callRoutingContractsremoveWhisperMessagedoWithHttpInfo($contract_id);
    }

    /**
     * Operation callRoutingContractsremoveWhisperMessagedoWithHttpInfo
     *
     * Remove Whisper Message
     *
     * @param  int $contract_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsremoveWhisperMessagedoWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsremoveWhisperMessagedoRequest($contract_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsremoveWhisperMessagedoAsync
     *
     * Remove Whisper Message
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsremoveWhisperMessagedoAsync($contract_id)
    {
        return $this->callRoutingContractsremoveWhisperMessagedoAsyncWithHttpInfo($contract_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsremoveWhisperMessagedoAsyncWithHttpInfo
     *
     * Remove Whisper Message
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsremoveWhisperMessagedoAsyncWithHttpInfo($contract_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractsremoveWhisperMessagedoRequest($contract_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsremoveWhisperMessagedo'
     *
     * @param  int $contract_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsremoveWhisperMessagedoRequest($contract_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsremoveWhisperMessagedo'
            );
        }

        $resourcePath = '/callRoutingContracts/removeWhisperMessage.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsrenamedo
     *
     * Rename
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $contract_name contract_name (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsrenamedo($contract_id, $contract_name)
    {
        $this->callRoutingContractsrenamedoWithHttpInfo($contract_id, $contract_name);
    }

    /**
     * Operation callRoutingContractsrenamedoWithHttpInfo
     *
     * Rename
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsrenamedoWithHttpInfo($contract_id, $contract_name)
    {
        $returnType = '';
        $request = $this->callRoutingContractsrenamedoRequest($contract_id, $contract_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsrenamedoAsync
     *
     * Rename
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsrenamedoAsync($contract_id, $contract_name)
    {
        return $this->callRoutingContractsrenamedoAsyncWithHttpInfo($contract_id, $contract_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsrenamedoAsyncWithHttpInfo
     *
     * Rename
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsrenamedoAsyncWithHttpInfo($contract_id, $contract_name)
    {
        $returnType = '';
        $request = $this->callRoutingContractsrenamedoRequest($contract_id, $contract_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsrenamedo'
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsrenamedoRequest($contract_id, $contract_name)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsrenamedo'
            );
        }
        // verify the required parameter 'contract_name' is set
        if ($contract_name === null || (is_array($contract_name) && count($contract_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_name when calling callRoutingContractsrenamedo'
            );
        }

        $resourcePath = '/callRoutingContracts/rename.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($contract_name !== null) {
            $queryParams['contractName'] = ObjectSerializer::toQueryValue($contract_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsschedulePausedo
     *
     * Schedule Pause
     *
     * @param  int $contract_id contract_id (required)
     * @param  \DateTime $pause_date pause_date (required)
     * @param  \DateTime $resume_date resume_date (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsschedulePausedo($contract_id, $pause_date, $resume_date)
    {
        $this->callRoutingContractsschedulePausedoWithHttpInfo($contract_id, $pause_date, $resume_date);
    }

    /**
     * Operation callRoutingContractsschedulePausedoWithHttpInfo
     *
     * Schedule Pause
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $pause_date (required)
     * @param  \DateTime $resume_date (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsschedulePausedoWithHttpInfo($contract_id, $pause_date, $resume_date)
    {
        $returnType = '';
        $request = $this->callRoutingContractsschedulePausedoRequest($contract_id, $pause_date, $resume_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsschedulePausedoAsync
     *
     * Schedule Pause
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $pause_date (required)
     * @param  \DateTime $resume_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsschedulePausedoAsync($contract_id, $pause_date, $resume_date)
    {
        return $this->callRoutingContractsschedulePausedoAsyncWithHttpInfo($contract_id, $pause_date, $resume_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsschedulePausedoAsyncWithHttpInfo
     *
     * Schedule Pause
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $pause_date (required)
     * @param  \DateTime $resume_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsschedulePausedoAsyncWithHttpInfo($contract_id, $pause_date, $resume_date)
    {
        $returnType = '';
        $request = $this->callRoutingContractsschedulePausedoRequest($contract_id, $pause_date, $resume_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsschedulePausedo'
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $pause_date (required)
     * @param  \DateTime $resume_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsschedulePausedoRequest($contract_id, $pause_date, $resume_date)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsschedulePausedo'
            );
        }
        // verify the required parameter 'pause_date' is set
        if ($pause_date === null || (is_array($pause_date) && count($pause_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pause_date when calling callRoutingContractsschedulePausedo'
            );
        }
        // verify the required parameter 'resume_date' is set
        if ($resume_date === null || (is_array($resume_date) && count($resume_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resume_date when calling callRoutingContractsschedulePausedo'
            );
        }

        $resourcePath = '/callRoutingContracts/schedulePause.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($pause_date !== null) {
            $queryParams['pauseDate'] = ObjectSerializer::toQueryValue($pause_date);
        }
        // query params
        if ($resume_date !== null) {
            $queryParams['resumeDate'] = ObjectSerializer::toQueryValue($resume_date);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractssetAudioWhisperMessagedo
     *
     * Set Audio Whisper Message
     *
     * @param  string $contract_id contract_id (required)
     * @param  int $audio_id audio_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractssetAudioWhisperMessagedo($contract_id, $audio_id)
    {
        $this->callRoutingContractssetAudioWhisperMessagedoWithHttpInfo($contract_id, $audio_id);
    }

    /**
     * Operation callRoutingContractssetAudioWhisperMessagedoWithHttpInfo
     *
     * Set Audio Whisper Message
     *
     * @param  string $contract_id (required)
     * @param  int $audio_id (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractssetAudioWhisperMessagedoWithHttpInfo($contract_id, $audio_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractssetAudioWhisperMessagedoRequest($contract_id, $audio_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractssetAudioWhisperMessagedoAsync
     *
     * Set Audio Whisper Message
     *
     * @param  string $contract_id (required)
     * @param  int $audio_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractssetAudioWhisperMessagedoAsync($contract_id, $audio_id)
    {
        return $this->callRoutingContractssetAudioWhisperMessagedoAsyncWithHttpInfo($contract_id, $audio_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractssetAudioWhisperMessagedoAsyncWithHttpInfo
     *
     * Set Audio Whisper Message
     *
     * @param  string $contract_id (required)
     * @param  int $audio_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractssetAudioWhisperMessagedoAsyncWithHttpInfo($contract_id, $audio_id)
    {
        $returnType = '';
        $request = $this->callRoutingContractssetAudioWhisperMessagedoRequest($contract_id, $audio_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractssetAudioWhisperMessagedo'
     *
     * @param  string $contract_id (required)
     * @param  int $audio_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractssetAudioWhisperMessagedoRequest($contract_id, $audio_id)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractssetAudioWhisperMessagedo'
            );
        }
        // verify the required parameter 'audio_id' is set
        if ($audio_id === null || (is_array($audio_id) && count($audio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audio_id when calling callRoutingContractssetAudioWhisperMessagedo'
            );
        }

        $resourcePath = '/callRoutingContracts/setAudioWhisperMessage.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($audio_id !== null) {
            $queryParams['audioID'] = ObjectSerializer::toQueryValue($audio_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractssetExpirationDatedo
     *
     * Set Expiration Date
     *
     * @param  int $contract_id contract_id (required)
     * @param  \DateTime $expiration_date expiration_date (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractssetExpirationDatedo($contract_id, $expiration_date)
    {
        $this->callRoutingContractssetExpirationDatedoWithHttpInfo($contract_id, $expiration_date);
    }

    /**
     * Operation callRoutingContractssetExpirationDatedoWithHttpInfo
     *
     * Set Expiration Date
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $expiration_date (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractssetExpirationDatedoWithHttpInfo($contract_id, $expiration_date)
    {
        $returnType = '';
        $request = $this->callRoutingContractssetExpirationDatedoRequest($contract_id, $expiration_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractssetExpirationDatedoAsync
     *
     * Set Expiration Date
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $expiration_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractssetExpirationDatedoAsync($contract_id, $expiration_date)
    {
        return $this->callRoutingContractssetExpirationDatedoAsyncWithHttpInfo($contract_id, $expiration_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractssetExpirationDatedoAsyncWithHttpInfo
     *
     * Set Expiration Date
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $expiration_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractssetExpirationDatedoAsyncWithHttpInfo($contract_id, $expiration_date)
    {
        $returnType = '';
        $request = $this->callRoutingContractssetExpirationDatedoRequest($contract_id, $expiration_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractssetExpirationDatedo'
     *
     * @param  int $contract_id (required)
     * @param  \DateTime $expiration_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractssetExpirationDatedoRequest($contract_id, $expiration_date)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractssetExpirationDatedo'
            );
        }
        // verify the required parameter 'expiration_date' is set
        if ($expiration_date === null || (is_array($expiration_date) && count($expiration_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expiration_date when calling callRoutingContractssetExpirationDatedo'
            );
        }

        $resourcePath = '/callRoutingContracts/setExpirationDate.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($expiration_date !== null) {
            $queryParams['expirationDate'] = ObjectSerializer::toQueryValue($expiration_date);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractssetTextToSpeechWhisperMessagedo
     *
     * Set Text-To-Speech Whisper Message
     *
     * @param  string $contract_id contract_id (required)
     * @param  string $message message (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractssetTextToSpeechWhisperMessagedo($contract_id, $message)
    {
        $this->callRoutingContractssetTextToSpeechWhisperMessagedoWithHttpInfo($contract_id, $message);
    }

    /**
     * Operation callRoutingContractssetTextToSpeechWhisperMessagedoWithHttpInfo
     *
     * Set Text-To-Speech Whisper Message
     *
     * @param  string $contract_id (required)
     * @param  string $message (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractssetTextToSpeechWhisperMessagedoWithHttpInfo($contract_id, $message)
    {
        $returnType = '';
        $request = $this->callRoutingContractssetTextToSpeechWhisperMessagedoRequest($contract_id, $message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractssetTextToSpeechWhisperMessagedoAsync
     *
     * Set Text-To-Speech Whisper Message
     *
     * @param  string $contract_id (required)
     * @param  string $message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractssetTextToSpeechWhisperMessagedoAsync($contract_id, $message)
    {
        return $this->callRoutingContractssetTextToSpeechWhisperMessagedoAsyncWithHttpInfo($contract_id, $message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractssetTextToSpeechWhisperMessagedoAsyncWithHttpInfo
     *
     * Set Text-To-Speech Whisper Message
     *
     * @param  string $contract_id (required)
     * @param  string $message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractssetTextToSpeechWhisperMessagedoAsyncWithHttpInfo($contract_id, $message)
    {
        $returnType = '';
        $request = $this->callRoutingContractssetTextToSpeechWhisperMessagedoRequest($contract_id, $message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractssetTextToSpeechWhisperMessagedo'
     *
     * @param  string $contract_id (required)
     * @param  string $message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractssetTextToSpeechWhisperMessagedoRequest($contract_id, $message)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractssetTextToSpeechWhisperMessagedo'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling callRoutingContractssetTextToSpeechWhisperMessagedo'
            );
        }

        $resourcePath = '/callRoutingContracts/setTextToSpeechWhisperMessage.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateBasicInfodo
     *
     * Update Basic Info
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $contract_name contract_name (optional)
     * @param  string $transfer_number transfer_number (optional)
     * @param  string $alternative_id alternative_id (optional)
     * @param  string $notes notes (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateBasicInfodo($contract_id, $contract_name = null, $transfer_number = null, $alternative_id = null, $notes = null)
    {
        $this->callRoutingContractsupdateBasicInfodoWithHttpInfo($contract_id, $contract_name, $transfer_number, $alternative_id, $notes);
    }

    /**
     * Operation callRoutingContractsupdateBasicInfodoWithHttpInfo
     *
     * Update Basic Info
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (optional)
     * @param  string $transfer_number (optional)
     * @param  string $alternative_id (optional)
     * @param  string $notes (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateBasicInfodoWithHttpInfo($contract_id, $contract_name = null, $transfer_number = null, $alternative_id = null, $notes = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateBasicInfodoRequest($contract_id, $contract_name, $transfer_number, $alternative_id, $notes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateBasicInfodoAsync
     *
     * Update Basic Info
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (optional)
     * @param  string $transfer_number (optional)
     * @param  string $alternative_id (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateBasicInfodoAsync($contract_id, $contract_name = null, $transfer_number = null, $alternative_id = null, $notes = null)
    {
        return $this->callRoutingContractsupdateBasicInfodoAsyncWithHttpInfo($contract_id, $contract_name, $transfer_number, $alternative_id, $notes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateBasicInfodoAsyncWithHttpInfo
     *
     * Update Basic Info
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (optional)
     * @param  string $transfer_number (optional)
     * @param  string $alternative_id (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateBasicInfodoAsyncWithHttpInfo($contract_id, $contract_name = null, $transfer_number = null, $alternative_id = null, $notes = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateBasicInfodoRequest($contract_id, $contract_name, $transfer_number, $alternative_id, $notes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateBasicInfodo'
     *
     * @param  int $contract_id (required)
     * @param  string $contract_name (optional)
     * @param  string $transfer_number (optional)
     * @param  string $alternative_id (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateBasicInfodoRequest($contract_id, $contract_name = null, $transfer_number = null, $alternative_id = null, $notes = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateBasicInfodo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateBasicInfo.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($contract_name !== null) {
            $queryParams['contractName'] = ObjectSerializer::toQueryValue($contract_name);
        }
        // query params
        if ($transfer_number !== null) {
            $queryParams['transferNumber'] = ObjectSerializer::toQueryValue($transfer_number);
        }
        // query params
        if ($alternative_id !== null) {
            $queryParams['alternativeID'] = ObjectSerializer::toQueryValue($alternative_id);
        }
        // query params
        if ($notes !== null) {
            $queryParams['notes'] = ObjectSerializer::toQueryValue($notes);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateBillableTransfersCapdo
     *
     * Update Billable Transfers Cap
     *
     * @param  int $contract_id contract_id (required)
     * @param  int $hourly_billable_cap hourly_billable_cap (optional)
     * @param  int $daily_billable_cap daily_billable_cap (optional)
     * @param  int $weekly_billable_cap weekly_billable_cap (optional)
     * @param  int $monthly_billable_cap monthly_billable_cap (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateBillableTransfersCapdo($contract_id, $hourly_billable_cap = null, $daily_billable_cap = null, $weekly_billable_cap = null, $monthly_billable_cap = null)
    {
        $this->callRoutingContractsupdateBillableTransfersCapdoWithHttpInfo($contract_id, $hourly_billable_cap, $daily_billable_cap, $weekly_billable_cap, $monthly_billable_cap);
    }

    /**
     * Operation callRoutingContractsupdateBillableTransfersCapdoWithHttpInfo
     *
     * Update Billable Transfers Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_billable_cap (optional)
     * @param  int $daily_billable_cap (optional)
     * @param  int $weekly_billable_cap (optional)
     * @param  int $monthly_billable_cap (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateBillableTransfersCapdoWithHttpInfo($contract_id, $hourly_billable_cap = null, $daily_billable_cap = null, $weekly_billable_cap = null, $monthly_billable_cap = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateBillableTransfersCapdoRequest($contract_id, $hourly_billable_cap, $daily_billable_cap, $weekly_billable_cap, $monthly_billable_cap);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateBillableTransfersCapdoAsync
     *
     * Update Billable Transfers Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_billable_cap (optional)
     * @param  int $daily_billable_cap (optional)
     * @param  int $weekly_billable_cap (optional)
     * @param  int $monthly_billable_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateBillableTransfersCapdoAsync($contract_id, $hourly_billable_cap = null, $daily_billable_cap = null, $weekly_billable_cap = null, $monthly_billable_cap = null)
    {
        return $this->callRoutingContractsupdateBillableTransfersCapdoAsyncWithHttpInfo($contract_id, $hourly_billable_cap, $daily_billable_cap, $weekly_billable_cap, $monthly_billable_cap)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateBillableTransfersCapdoAsyncWithHttpInfo
     *
     * Update Billable Transfers Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_billable_cap (optional)
     * @param  int $daily_billable_cap (optional)
     * @param  int $weekly_billable_cap (optional)
     * @param  int $monthly_billable_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateBillableTransfersCapdoAsyncWithHttpInfo($contract_id, $hourly_billable_cap = null, $daily_billable_cap = null, $weekly_billable_cap = null, $monthly_billable_cap = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateBillableTransfersCapdoRequest($contract_id, $hourly_billable_cap, $daily_billable_cap, $weekly_billable_cap, $monthly_billable_cap);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateBillableTransfersCapdo'
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_billable_cap (optional)
     * @param  int $daily_billable_cap (optional)
     * @param  int $weekly_billable_cap (optional)
     * @param  int $monthly_billable_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateBillableTransfersCapdoRequest($contract_id, $hourly_billable_cap = null, $daily_billable_cap = null, $weekly_billable_cap = null, $monthly_billable_cap = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateBillableTransfersCapdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateBillableTransfersCap.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($hourly_billable_cap !== null) {
            $queryParams['hourlyBillableCap'] = ObjectSerializer::toQueryValue($hourly_billable_cap);
        }
        // query params
        if ($daily_billable_cap !== null) {
            $queryParams['dailyBillableCap'] = ObjectSerializer::toQueryValue($daily_billable_cap);
        }
        // query params
        if ($weekly_billable_cap !== null) {
            $queryParams['weeklyBillableCap'] = ObjectSerializer::toQueryValue($weekly_billable_cap);
        }
        // query params
        if ($monthly_billable_cap !== null) {
            $queryParams['monthlyBillableCap'] = ObjectSerializer::toQueryValue($monthly_billable_cap);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdatePortalSettingsdo
     *
     * Update Portal Settings
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $show_status show_status (optional)
     * @param  string $show_schedule show_schedule (optional)
     * @param  string $show_caps show_caps (optional)
     * @param  string $show_return_settings show_return_settings (optional)
     * @param  string $allow_status_pause allow_status_pause (optional)
     * @param  string $allow_update_schedule allow_update_schedule (optional)
     * @param  string $allow_manage_caps allow_manage_caps (optional)
     * @param  string $call_recordings call_recordings (optional)
     * @param  string $hide_caller_id hide_caller_id (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdatePortalSettingsdo($contract_id, $show_status = null, $show_schedule = null, $show_caps = null, $show_return_settings = null, $allow_status_pause = null, $allow_update_schedule = null, $allow_manage_caps = null, $call_recordings = null, $hide_caller_id = null)
    {
        $this->callRoutingContractsupdatePortalSettingsdoWithHttpInfo($contract_id, $show_status, $show_schedule, $show_caps, $show_return_settings, $allow_status_pause, $allow_update_schedule, $allow_manage_caps, $call_recordings, $hide_caller_id);
    }

    /**
     * Operation callRoutingContractsupdatePortalSettingsdoWithHttpInfo
     *
     * Update Portal Settings
     *
     * @param  int $contract_id (required)
     * @param  string $show_status (optional)
     * @param  string $show_schedule (optional)
     * @param  string $show_caps (optional)
     * @param  string $show_return_settings (optional)
     * @param  string $allow_status_pause (optional)
     * @param  string $allow_update_schedule (optional)
     * @param  string $allow_manage_caps (optional)
     * @param  string $call_recordings (optional)
     * @param  string $hide_caller_id (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdatePortalSettingsdoWithHttpInfo($contract_id, $show_status = null, $show_schedule = null, $show_caps = null, $show_return_settings = null, $allow_status_pause = null, $allow_update_schedule = null, $allow_manage_caps = null, $call_recordings = null, $hide_caller_id = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdatePortalSettingsdoRequest($contract_id, $show_status, $show_schedule, $show_caps, $show_return_settings, $allow_status_pause, $allow_update_schedule, $allow_manage_caps, $call_recordings, $hide_caller_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdatePortalSettingsdoAsync
     *
     * Update Portal Settings
     *
     * @param  int $contract_id (required)
     * @param  string $show_status (optional)
     * @param  string $show_schedule (optional)
     * @param  string $show_caps (optional)
     * @param  string $show_return_settings (optional)
     * @param  string $allow_status_pause (optional)
     * @param  string $allow_update_schedule (optional)
     * @param  string $allow_manage_caps (optional)
     * @param  string $call_recordings (optional)
     * @param  string $hide_caller_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdatePortalSettingsdoAsync($contract_id, $show_status = null, $show_schedule = null, $show_caps = null, $show_return_settings = null, $allow_status_pause = null, $allow_update_schedule = null, $allow_manage_caps = null, $call_recordings = null, $hide_caller_id = null)
    {
        return $this->callRoutingContractsupdatePortalSettingsdoAsyncWithHttpInfo($contract_id, $show_status, $show_schedule, $show_caps, $show_return_settings, $allow_status_pause, $allow_update_schedule, $allow_manage_caps, $call_recordings, $hide_caller_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdatePortalSettingsdoAsyncWithHttpInfo
     *
     * Update Portal Settings
     *
     * @param  int $contract_id (required)
     * @param  string $show_status (optional)
     * @param  string $show_schedule (optional)
     * @param  string $show_caps (optional)
     * @param  string $show_return_settings (optional)
     * @param  string $allow_status_pause (optional)
     * @param  string $allow_update_schedule (optional)
     * @param  string $allow_manage_caps (optional)
     * @param  string $call_recordings (optional)
     * @param  string $hide_caller_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdatePortalSettingsdoAsyncWithHttpInfo($contract_id, $show_status = null, $show_schedule = null, $show_caps = null, $show_return_settings = null, $allow_status_pause = null, $allow_update_schedule = null, $allow_manage_caps = null, $call_recordings = null, $hide_caller_id = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdatePortalSettingsdoRequest($contract_id, $show_status, $show_schedule, $show_caps, $show_return_settings, $allow_status_pause, $allow_update_schedule, $allow_manage_caps, $call_recordings, $hide_caller_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdatePortalSettingsdo'
     *
     * @param  int $contract_id (required)
     * @param  string $show_status (optional)
     * @param  string $show_schedule (optional)
     * @param  string $show_caps (optional)
     * @param  string $show_return_settings (optional)
     * @param  string $allow_status_pause (optional)
     * @param  string $allow_update_schedule (optional)
     * @param  string $allow_manage_caps (optional)
     * @param  string $call_recordings (optional)
     * @param  string $hide_caller_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdatePortalSettingsdoRequest($contract_id, $show_status = null, $show_schedule = null, $show_caps = null, $show_return_settings = null, $allow_status_pause = null, $allow_update_schedule = null, $allow_manage_caps = null, $call_recordings = null, $hide_caller_id = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdatePortalSettingsdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updatePortalSettings.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($show_status !== null) {
            $queryParams['showStatus'] = ObjectSerializer::toQueryValue($show_status);
        }
        // query params
        if ($show_schedule !== null) {
            $queryParams['showSchedule'] = ObjectSerializer::toQueryValue($show_schedule);
        }
        // query params
        if ($show_caps !== null) {
            $queryParams['showCaps'] = ObjectSerializer::toQueryValue($show_caps);
        }
        // query params
        if ($show_return_settings !== null) {
            $queryParams['showReturnSettings'] = ObjectSerializer::toQueryValue($show_return_settings);
        }
        // query params
        if ($allow_status_pause !== null) {
            $queryParams['allowStatusPause'] = ObjectSerializer::toQueryValue($allow_status_pause);
        }
        // query params
        if ($allow_update_schedule !== null) {
            $queryParams['allowUpdateSchedule'] = ObjectSerializer::toQueryValue($allow_update_schedule);
        }
        // query params
        if ($allow_manage_caps !== null) {
            $queryParams['allowManageCaps'] = ObjectSerializer::toQueryValue($allow_manage_caps);
        }
        // query params
        if ($call_recordings !== null) {
            $queryParams['callRecordings'] = ObjectSerializer::toQueryValue($call_recordings);
        }
        // query params
        if ($hide_caller_id !== null) {
            $queryParams['hideCallerID'] = ObjectSerializer::toQueryValue($hide_caller_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateRepeatCallsSettingsdo
     *
     * Update Repeat Calls Settings
     *
     * @param  int $contract_id contract_id (required)
     * @param  int $repeat_call_days repeat_call_days (optional)
     * @param  string $transfer_repeat transfer_repeat (optional)
     * @param  string $repeat_billable repeat_billable (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateRepeatCallsSettingsdo($contract_id, $repeat_call_days = null, $transfer_repeat = null, $repeat_billable = null)
    {
        $this->callRoutingContractsupdateRepeatCallsSettingsdoWithHttpInfo($contract_id, $repeat_call_days, $transfer_repeat, $repeat_billable);
    }

    /**
     * Operation callRoutingContractsupdateRepeatCallsSettingsdoWithHttpInfo
     *
     * Update Repeat Calls Settings
     *
     * @param  int $contract_id (required)
     * @param  int $repeat_call_days (optional)
     * @param  string $transfer_repeat (optional)
     * @param  string $repeat_billable (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateRepeatCallsSettingsdoWithHttpInfo($contract_id, $repeat_call_days = null, $transfer_repeat = null, $repeat_billable = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateRepeatCallsSettingsdoRequest($contract_id, $repeat_call_days, $transfer_repeat, $repeat_billable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateRepeatCallsSettingsdoAsync
     *
     * Update Repeat Calls Settings
     *
     * @param  int $contract_id (required)
     * @param  int $repeat_call_days (optional)
     * @param  string $transfer_repeat (optional)
     * @param  string $repeat_billable (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateRepeatCallsSettingsdoAsync($contract_id, $repeat_call_days = null, $transfer_repeat = null, $repeat_billable = null)
    {
        return $this->callRoutingContractsupdateRepeatCallsSettingsdoAsyncWithHttpInfo($contract_id, $repeat_call_days, $transfer_repeat, $repeat_billable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateRepeatCallsSettingsdoAsyncWithHttpInfo
     *
     * Update Repeat Calls Settings
     *
     * @param  int $contract_id (required)
     * @param  int $repeat_call_days (optional)
     * @param  string $transfer_repeat (optional)
     * @param  string $repeat_billable (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateRepeatCallsSettingsdoAsyncWithHttpInfo($contract_id, $repeat_call_days = null, $transfer_repeat = null, $repeat_billable = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateRepeatCallsSettingsdoRequest($contract_id, $repeat_call_days, $transfer_repeat, $repeat_billable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateRepeatCallsSettingsdo'
     *
     * @param  int $contract_id (required)
     * @param  int $repeat_call_days (optional)
     * @param  string $transfer_repeat (optional)
     * @param  string $repeat_billable (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateRepeatCallsSettingsdoRequest($contract_id, $repeat_call_days = null, $transfer_repeat = null, $repeat_billable = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateRepeatCallsSettingsdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateRepeatCallsSettings.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($repeat_call_days !== null) {
            $queryParams['repeatCallDays'] = ObjectSerializer::toQueryValue($repeat_call_days);
        }
        // query params
        if ($transfer_repeat !== null) {
            $queryParams['transferRepeat'] = ObjectSerializer::toQueryValue($transfer_repeat);
        }
        // query params
        if ($repeat_billable !== null) {
            $queryParams['repeatBillable'] = ObjectSerializer::toQueryValue($repeat_billable);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateReturnsSettingsdo
     *
     * Update Returns Settings
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $allow_returns allow_returns (optional)
     * @param  string $auto_approve_returns auto_approve_returns (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateReturnsSettingsdo($contract_id, $allow_returns = null, $auto_approve_returns = null)
    {
        $this->callRoutingContractsupdateReturnsSettingsdoWithHttpInfo($contract_id, $allow_returns, $auto_approve_returns);
    }

    /**
     * Operation callRoutingContractsupdateReturnsSettingsdoWithHttpInfo
     *
     * Update Returns Settings
     *
     * @param  int $contract_id (required)
     * @param  string $allow_returns (optional)
     * @param  string $auto_approve_returns (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateReturnsSettingsdoWithHttpInfo($contract_id, $allow_returns = null, $auto_approve_returns = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateReturnsSettingsdoRequest($contract_id, $allow_returns, $auto_approve_returns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateReturnsSettingsdoAsync
     *
     * Update Returns Settings
     *
     * @param  int $contract_id (required)
     * @param  string $allow_returns (optional)
     * @param  string $auto_approve_returns (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateReturnsSettingsdoAsync($contract_id, $allow_returns = null, $auto_approve_returns = null)
    {
        return $this->callRoutingContractsupdateReturnsSettingsdoAsyncWithHttpInfo($contract_id, $allow_returns, $auto_approve_returns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateReturnsSettingsdoAsyncWithHttpInfo
     *
     * Update Returns Settings
     *
     * @param  int $contract_id (required)
     * @param  string $allow_returns (optional)
     * @param  string $auto_approve_returns (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateReturnsSettingsdoAsyncWithHttpInfo($contract_id, $allow_returns = null, $auto_approve_returns = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateReturnsSettingsdoRequest($contract_id, $allow_returns, $auto_approve_returns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateReturnsSettingsdo'
     *
     * @param  int $contract_id (required)
     * @param  string $allow_returns (optional)
     * @param  string $auto_approve_returns (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateReturnsSettingsdoRequest($contract_id, $allow_returns = null, $auto_approve_returns = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateReturnsSettingsdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateReturnsSettings.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($allow_returns !== null) {
            $queryParams['allowReturns'] = ObjectSerializer::toQueryValue($allow_returns);
        }
        // query params
        if ($auto_approve_returns !== null) {
            $queryParams['autoApproveReturns'] = ObjectSerializer::toQueryValue($auto_approve_returns);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateRevenueCapdo
     *
     * Update Revenue Cap
     *
     * @param  int $contract_id contract_id (required)
     * @param  int $hourly_revenue_cap hourly_revenue_cap (optional)
     * @param  int $daily_revenue_cap daily_revenue_cap (optional)
     * @param  int $weekly_revenue_cap weekly_revenue_cap (optional)
     * @param  int $monthly_revenue_cap monthly_revenue_cap (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateRevenueCapdo($contract_id, $hourly_revenue_cap = null, $daily_revenue_cap = null, $weekly_revenue_cap = null, $monthly_revenue_cap = null)
    {
        $this->callRoutingContractsupdateRevenueCapdoWithHttpInfo($contract_id, $hourly_revenue_cap, $daily_revenue_cap, $weekly_revenue_cap, $monthly_revenue_cap);
    }

    /**
     * Operation callRoutingContractsupdateRevenueCapdoWithHttpInfo
     *
     * Update Revenue Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_revenue_cap (optional)
     * @param  int $daily_revenue_cap (optional)
     * @param  int $weekly_revenue_cap (optional)
     * @param  int $monthly_revenue_cap (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateRevenueCapdoWithHttpInfo($contract_id, $hourly_revenue_cap = null, $daily_revenue_cap = null, $weekly_revenue_cap = null, $monthly_revenue_cap = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateRevenueCapdoRequest($contract_id, $hourly_revenue_cap, $daily_revenue_cap, $weekly_revenue_cap, $monthly_revenue_cap);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateRevenueCapdoAsync
     *
     * Update Revenue Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_revenue_cap (optional)
     * @param  int $daily_revenue_cap (optional)
     * @param  int $weekly_revenue_cap (optional)
     * @param  int $monthly_revenue_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateRevenueCapdoAsync($contract_id, $hourly_revenue_cap = null, $daily_revenue_cap = null, $weekly_revenue_cap = null, $monthly_revenue_cap = null)
    {
        return $this->callRoutingContractsupdateRevenueCapdoAsyncWithHttpInfo($contract_id, $hourly_revenue_cap, $daily_revenue_cap, $weekly_revenue_cap, $monthly_revenue_cap)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateRevenueCapdoAsyncWithHttpInfo
     *
     * Update Revenue Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_revenue_cap (optional)
     * @param  int $daily_revenue_cap (optional)
     * @param  int $weekly_revenue_cap (optional)
     * @param  int $monthly_revenue_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateRevenueCapdoAsyncWithHttpInfo($contract_id, $hourly_revenue_cap = null, $daily_revenue_cap = null, $weekly_revenue_cap = null, $monthly_revenue_cap = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateRevenueCapdoRequest($contract_id, $hourly_revenue_cap, $daily_revenue_cap, $weekly_revenue_cap, $monthly_revenue_cap);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateRevenueCapdo'
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_revenue_cap (optional)
     * @param  int $daily_revenue_cap (optional)
     * @param  int $weekly_revenue_cap (optional)
     * @param  int $monthly_revenue_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateRevenueCapdoRequest($contract_id, $hourly_revenue_cap = null, $daily_revenue_cap = null, $weekly_revenue_cap = null, $monthly_revenue_cap = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateRevenueCapdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateRevenueCap.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($hourly_revenue_cap !== null) {
            $queryParams['hourlyRevenueCap'] = ObjectSerializer::toQueryValue($hourly_revenue_cap);
        }
        // query params
        if ($daily_revenue_cap !== null) {
            $queryParams['dailyRevenueCap'] = ObjectSerializer::toQueryValue($daily_revenue_cap);
        }
        // query params
        if ($weekly_revenue_cap !== null) {
            $queryParams['weeklyRevenueCap'] = ObjectSerializer::toQueryValue($weekly_revenue_cap);
        }
        // query params
        if ($monthly_revenue_cap !== null) {
            $queryParams['monthlyRevenueCap'] = ObjectSerializer::toQueryValue($monthly_revenue_cap);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateRevenueModeldo
     *
     * Update Revenue Model
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $revenue_model revenue_model (required)
     * @param  BigDecimal $price price (required)
     * @param  string $duration duration (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateRevenueModeldo($contract_id, $revenue_model, $price, $duration = null)
    {
        $this->callRoutingContractsupdateRevenueModeldoWithHttpInfo($contract_id, $revenue_model, $price, $duration);
    }

    /**
     * Operation callRoutingContractsupdateRevenueModeldoWithHttpInfo
     *
     * Update Revenue Model
     *
     * @param  int $contract_id (required)
     * @param  string $revenue_model (required)
     * @param  BigDecimal $price (required)
     * @param  string $duration (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateRevenueModeldoWithHttpInfo($contract_id, $revenue_model, $price, $duration = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateRevenueModeldoRequest($contract_id, $revenue_model, $price, $duration);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateRevenueModeldoAsync
     *
     * Update Revenue Model
     *
     * @param  int $contract_id (required)
     * @param  string $revenue_model (required)
     * @param  BigDecimal $price (required)
     * @param  string $duration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateRevenueModeldoAsync($contract_id, $revenue_model, $price, $duration = null)
    {
        return $this->callRoutingContractsupdateRevenueModeldoAsyncWithHttpInfo($contract_id, $revenue_model, $price, $duration)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateRevenueModeldoAsyncWithHttpInfo
     *
     * Update Revenue Model
     *
     * @param  int $contract_id (required)
     * @param  string $revenue_model (required)
     * @param  BigDecimal $price (required)
     * @param  string $duration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateRevenueModeldoAsyncWithHttpInfo($contract_id, $revenue_model, $price, $duration = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateRevenueModeldoRequest($contract_id, $revenue_model, $price, $duration);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateRevenueModeldo'
     *
     * @param  int $contract_id (required)
     * @param  string $revenue_model (required)
     * @param  BigDecimal $price (required)
     * @param  string $duration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateRevenueModeldoRequest($contract_id, $revenue_model, $price, $duration = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateRevenueModeldo'
            );
        }
        // verify the required parameter 'revenue_model' is set
        if ($revenue_model === null || (is_array($revenue_model) && count($revenue_model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $revenue_model when calling callRoutingContractsupdateRevenueModeldo'
            );
        }
        // verify the required parameter 'price' is set
        if ($price === null || (is_array($price) && count($price) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price when calling callRoutingContractsupdateRevenueModeldo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateRevenueModel.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($revenue_model !== null) {
            $queryParams['revenueModel'] = ObjectSerializer::toQueryValue($revenue_model);
        }
        // query params
        if ($price !== null) {
            $queryParams['price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateTransferNumberdo
     *
     * Update Transfer Number
     *
     * @param  int $contract_id contract_id (required)
     * @param  string $transfer_number transfer_number (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateTransferNumberdo($contract_id, $transfer_number)
    {
        $this->callRoutingContractsupdateTransferNumberdoWithHttpInfo($contract_id, $transfer_number);
    }

    /**
     * Operation callRoutingContractsupdateTransferNumberdoWithHttpInfo
     *
     * Update Transfer Number
     *
     * @param  int $contract_id (required)
     * @param  string $transfer_number (required)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateTransferNumberdoWithHttpInfo($contract_id, $transfer_number)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateTransferNumberdoRequest($contract_id, $transfer_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateTransferNumberdoAsync
     *
     * Update Transfer Number
     *
     * @param  int $contract_id (required)
     * @param  string $transfer_number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateTransferNumberdoAsync($contract_id, $transfer_number)
    {
        return $this->callRoutingContractsupdateTransferNumberdoAsyncWithHttpInfo($contract_id, $transfer_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateTransferNumberdoAsyncWithHttpInfo
     *
     * Update Transfer Number
     *
     * @param  int $contract_id (required)
     * @param  string $transfer_number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateTransferNumberdoAsyncWithHttpInfo($contract_id, $transfer_number)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateTransferNumberdoRequest($contract_id, $transfer_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateTransferNumberdo'
     *
     * @param  int $contract_id (required)
     * @param  string $transfer_number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateTransferNumberdoRequest($contract_id, $transfer_number)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateTransferNumberdo'
            );
        }
        // verify the required parameter 'transfer_number' is set
        if ($transfer_number === null || (is_array($transfer_number) && count($transfer_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transfer_number when calling callRoutingContractsupdateTransferNumberdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateTransferNumber.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($transfer_number !== null) {
            $queryParams['transferNumber'] = ObjectSerializer::toQueryValue($transfer_number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callRoutingContractsupdateTransfersCapdo
     *
     * Update Transfers Cap
     *
     * @param  int $contract_id contract_id (required)
     * @param  int $hourly_transfers_cap hourly_transfers_cap (optional)
     * @param  int $daily_transfers_cap daily_transfers_cap (optional)
     * @param  int $weekly_transfers_cap weekly_transfers_cap (optional)
     * @param  int $monthly_transfers_cap monthly_transfers_cap (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callRoutingContractsupdateTransfersCapdo($contract_id, $hourly_transfers_cap = null, $daily_transfers_cap = null, $weekly_transfers_cap = null, $monthly_transfers_cap = null)
    {
        $this->callRoutingContractsupdateTransfersCapdoWithHttpInfo($contract_id, $hourly_transfers_cap, $daily_transfers_cap, $weekly_transfers_cap, $monthly_transfers_cap);
    }

    /**
     * Operation callRoutingContractsupdateTransfersCapdoWithHttpInfo
     *
     * Update Transfers Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_transfers_cap (optional)
     * @param  int $daily_transfers_cap (optional)
     * @param  int $weekly_transfers_cap (optional)
     * @param  int $monthly_transfers_cap (optional)
     *
     * @throws \LeadspediaApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callRoutingContractsupdateTransfersCapdoWithHttpInfo($contract_id, $hourly_transfers_cap = null, $daily_transfers_cap = null, $weekly_transfers_cap = null, $monthly_transfers_cap = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateTransfersCapdoRequest($contract_id, $hourly_transfers_cap, $daily_transfers_cap, $weekly_transfers_cap, $monthly_transfers_cap);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callRoutingContractsupdateTransfersCapdoAsync
     *
     * Update Transfers Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_transfers_cap (optional)
     * @param  int $daily_transfers_cap (optional)
     * @param  int $weekly_transfers_cap (optional)
     * @param  int $monthly_transfers_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateTransfersCapdoAsync($contract_id, $hourly_transfers_cap = null, $daily_transfers_cap = null, $weekly_transfers_cap = null, $monthly_transfers_cap = null)
    {
        return $this->callRoutingContractsupdateTransfersCapdoAsyncWithHttpInfo($contract_id, $hourly_transfers_cap, $daily_transfers_cap, $weekly_transfers_cap, $monthly_transfers_cap)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callRoutingContractsupdateTransfersCapdoAsyncWithHttpInfo
     *
     * Update Transfers Cap
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_transfers_cap (optional)
     * @param  int $daily_transfers_cap (optional)
     * @param  int $weekly_transfers_cap (optional)
     * @param  int $monthly_transfers_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callRoutingContractsupdateTransfersCapdoAsyncWithHttpInfo($contract_id, $hourly_transfers_cap = null, $daily_transfers_cap = null, $weekly_transfers_cap = null, $monthly_transfers_cap = null)
    {
        $returnType = '';
        $request = $this->callRoutingContractsupdateTransfersCapdoRequest($contract_id, $hourly_transfers_cap, $daily_transfers_cap, $weekly_transfers_cap, $monthly_transfers_cap);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callRoutingContractsupdateTransfersCapdo'
     *
     * @param  int $contract_id (required)
     * @param  int $hourly_transfers_cap (optional)
     * @param  int $daily_transfers_cap (optional)
     * @param  int $weekly_transfers_cap (optional)
     * @param  int $monthly_transfers_cap (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callRoutingContractsupdateTransfersCapdoRequest($contract_id, $hourly_transfers_cap = null, $daily_transfers_cap = null, $weekly_transfers_cap = null, $monthly_transfers_cap = null)
    {
        // verify the required parameter 'contract_id' is set
        if ($contract_id === null || (is_array($contract_id) && count($contract_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_id when calling callRoutingContractsupdateTransfersCapdo'
            );
        }

        $resourcePath = '/callRoutingContracts/updateTransfersCap.do';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract_id !== null) {
            $queryParams['contractID'] = ObjectSerializer::toQueryValue($contract_id);
        }
        // query params
        if ($hourly_transfers_cap !== null) {
            $queryParams['hourlyTransfersCap'] = ObjectSerializer::toQueryValue($hourly_transfers_cap);
        }
        // query params
        if ($daily_transfers_cap !== null) {
            $queryParams['dailyTransfersCap'] = ObjectSerializer::toQueryValue($daily_transfers_cap);
        }
        // query params
        if ($weekly_transfers_cap !== null) {
            $queryParams['weeklyTransfersCap'] = ObjectSerializer::toQueryValue($weekly_transfers_cap);
        }
        // query params
        if ($monthly_transfers_cap !== null) {
            $queryParams['monthlyTransfersCap'] = ObjectSerializer::toQueryValue($monthly_transfers_cap);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_secret');
        if ($apiKey !== null) {
            $queryParams['api_secret'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
